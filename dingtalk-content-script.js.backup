// 防止重复注入
if (window.__dingtalkContentScriptInjected__) {
  // 已经注入，跳过
} else {
  window.__dingtalkContentScriptInjected__ = true;

  let XPATH = '/html/body/div[1]/div/div/div[1]/div/div/div[2]/div[5]/div/div/button';

  const EXT_HINT = /\.(xlsx?|csv|zip|pdf|txt|json|xlsb|xlsm|ods)(\?|#|$)/i;
  const URL_HINT = /(download|export|exportFile|file\/download|exportExcel|exportCsv|\/download)/i;
  const BTN_TEXT_HINT = /(下载|导出|download|export)/i;

  // 报告发现
  function reportFound(how, url) {
    if (!url) return;
    chrome.runtime.sendMessage({ type: "FOUND_URL", how, url }, (response) => {
      if (chrome.runtime.lastError) {
        // 忽略错误
      }
    });
    try {
      // 只在文档有焦点时尝试写入剪贴板
      if (document.hasFocus()) {
        navigator.clipboard?.writeText?.(url);
      }
    } catch (error) {
      // 忽略剪贴板错误
    }
  }

  // XPath 工具
  function getByXPath(xpath, context = document) {
    try {
      const r = document.evaluate(xpath, context, null, XPathResult.FIRST_ORDERED_NODE_TYPE, null);
      return r.singleNodeValue || null;
    } catch (e) {
      return null;
    }
  }
  async function waitForXPath(xpath, timeout = 8000) {
    const t0 = performance.now();
    while (performance.now() - t0 < timeout) {
      const el = getByXPath(xpath);
      if (el) {
        return el;
      }
      await new Promise(r => setTimeout(r, 120));
    }
    return null;
  }

  // --- Hook fetch/XHR/<a>.click/window.open/DOM ---
  (function installHooks(){
    const origFetch = window.fetch;
    window.fetch = async function(...args){
      const input = args[0];
      const reqUrl = typeof input === "string" ? input : input?.url;
      const res = await origFetch.apply(this, args);
      try {
        const disp = res.headers.get('content-disposition');
        if (disp && /attachment|filename/i.test(disp)) {
          reportFound('fetch content-disposition', reqUrl || '[ResponseStream]');
        }
        else if (reqUrl && (EXT_HINT.test(reqUrl) || URL_HINT.test(reqUrl))) {
          reportFound('fetch url', reqUrl);
        }
      } catch {}
      return res;
    };

    const origOpen = XMLHttpRequest.prototype.open;
    const origSend = XMLHttpRequest.prototype.send;
    XMLHttpRequest.prototype.open = function(method, url, ...rest){
      this.__dl_url__ = url;
      return origOpen.call(this, method, url, ...rest);
    };
    XMLHttpRequest.prototype.send = function(...args){
      this.addEventListener('load', () => {
        try {
          const url = this.responseURL || this.__dl_url__;
          const disp = this.getResponseHeader?.('content-disposition');
          if (disp && /attachment|filename/i.test(disp)) reportFound('xhr content-disposition', url || '[ResponseStream]');
          else if (url && (EXT_HINT.test(url) || URL_HINT.test(url))) reportFound('xhr url', url);
        } catch {}
      });
      return origSend.apply(this, args);
    };

    const origAnchorClick = HTMLAnchorElement.prototype.click;
    HTMLAnchorElement.prototype.click = function(...args){
      const href = this.href || this.getAttribute('href') || '';
      if ((this.hasAttribute('download') || URL_HINT.test(href) || EXT_HINT.test(href)) && href) {
        reportFound('anchor href', href);
      }
      return origAnchorClick.apply(this, args);
    };

    const origOpenWin = window.open;
    window.open = function(url, ...rest){
      if (url && (EXT_HINT.test(url) || URL_HINT.test(url))) reportFound('window.open url', url);
      return origOpenWin.call(this, url, ...rest);
    };

    const mo = new MutationObserver(muts => {
      for (const mut of muts) {
        for (const n of mut.addedNodes || []) {
          if (!(n instanceof Element)) continue;
          if (n.tagName === 'A') {
            const href = n.href || n.getAttribute('href') || '';
            if ((n.hasAttribute('download') || URL_HINT.test(href) || EXT_HINT.test(href)) && href) {
              reportFound('dom anchor', href);
              return;
            }
          }
          if (n.tagName === 'IFRAME') {
            const src = n.getAttribute('src') || '';
            if (src && (URL_HINT.test(src) || EXT_HINT.test(src))) {
              reportFound('iframe src', src);
              return;
            }
          }
          const a2 = n.querySelector?.('a[download], a[href*="download"], a[href*="export"], a[href$=".xlsx"], a[href$=".csv"], a[href$=".xls"], a[href$=".zip"]');
          if (a2) {
            const href2 = a2.href || a2.getAttribute('href') || '';
            if (href2) { reportFound('dom anchor (deep)', href2); return; }
          }
        }
      }
    });
    try { mo.observe(document.documentElement, { childList: true, subtree: true }); } catch {}

  })();

  // 处理 CLICK_NOW 消息的函数
  async function handleClickNow(sendResponse) {
    const btn = await waitForXPath(XPATH, 8000);

    if (btn) {
      try {
        // Remove disabled attribute if present
        if (btn.hasAttribute('disabled')) {
          btn.removeAttribute('disabled');
        }

        btn.dispatchEvent(new MouseEvent('click', { bubbles: true, cancelable: true, view: window }));
        sendResponse({ success: true, msg: "已点击 XPath 按钮" });
      } catch (e) {
        try {
          btn.click();
          sendResponse({ success: true, msg: "已 click()" });
        }
        catch (e2) {
          sendResponse({ success: false, msg: String(e2) });
        }
      }
    } else {
      sendResponse({ success: false, msg: "未找到 XPath 按钮（可能在 Shadow DOM 或尚未渲染）" });
    }
  }

  // 新增：处理 API 下载请求
  async function handleApiDownload(sendResponse) {
    try {
      console.log('[DingTalk] Starting handleApiDownload');

      // 从当前URL提取dentryUuid
      const url = window.location.href;
      console.log('[DingTalk] Current URL:', url);

      // 修复正则表达式以匹配正确的URL格式
      const dingTalkMatch = url.match(/alidocs\.dingtalk\.com\/i\/nodes\/([a-zA-Z0-9_-]+)/);
      const previewMatch = url.match(/alidocs\.dingtalk\.com\/uni-preview.*dentryUuid=([a-zA-Z0-9]+)/);

      let dentryUuid = null;
      if (dingTalkMatch) {
        dentryUuid = dingTalkMatch[1];
        console.log('[DingTalk] Found dentryUuid from nodes URL:', dentryUuid);
      } else if (previewMatch) {
        dentryUuid = previewMatch[1];
        console.log('[DingTalk] Found dentryUuid from preview URL:', dentryUuid);
      }

      if (!dentryUuid) {
        throw new Error('Could not extract dentryUuid from URL. URL pattern: ' + url);
      }

      console.log('[DingTalk] Extracted dentryUuid:', dentryUuid);

      // 监听网络请求来获取真实的下载URL
      return new Promise((resolve) => {
        const originalFetch = window.fetch;

        window.fetch = async function(...args) {
          const input = args[0];
          const reqUrl = typeof input === "string" ? input : input?.url;

          // 检查是否是下载相关的URL
          if (reqUrl && reqUrl.includes('download') && (reqUrl.includes('.xlsx') || reqUrl.includes('.csv') || reqUrl.includes('xls'))) {
            // 找到真实的下载URL
            window.fetch = originalFetch; // 恢复原始fetch

            // 返回真实的下载URL
            resolve({
              success: true,
              downloadUrl: reqUrl,
              filename: `dingtalk_document_${dentryUuid}.xlsx`,
              msg: "Download URL obtained from network monitoring"
            });

            // 继续原始请求
            return originalFetch.apply(this, args);
          }

          return originalFetch.apply(this, args);
        };

        // 构建API URL并触发下载
        const apiUrl = `https://alidocs.dingtalk.com/box/api/v2/file/download?dentryUuid=${dentryUuid}&version=1&supportDownloadTypes=URL_PRE_SIGNATURE,HTTP_TO_CENTER&downloadType=URL_PRE_SIGNATURE`;

        // 发送GET请求来触发网络活动
        fetch(apiUrl, {
          method: 'GET',
          headers: {
            'Accept': 'application/json',
          }
        }).then(response => response.json()).then(data => {
          // 如果通过API获取到了URL，也使用它
          if (data.isSuccess && data.data && data.data.ossUrlPreSignatureInfo && data.data.ossUrlPreSignatureInfo.preSignUrls) {
            window.fetch = originalFetch; // 恢复原始fetch

            const downloadUrl = data.data.ossUrlPreSignatureInfo.preSignUrls[0];
            resolve({
              success: true,
              downloadUrl: downloadUrl,
              filename: `dingtalk_document_${dentryUuid}.xlsx`,
              msg: "Download URL obtained from API"
            });
          }
        }).catch(() => {
          // 如果API失败，继续等待fetch hook捕获
        });

        // 10秒超时
        setTimeout(() => {
          window.fetch = originalFetch;
          resolve({
            success: false,
            msg: "Timeout waiting for download URL"
          });
        }, 10000);
      }).then(result => {
        sendResponse(result);
      });

    } catch (error) {
      sendResponse({ success: false, msg: error.message });
    }
  }

  // 接收 popup 的指令：更新 XPath、自动点击
  chrome.runtime.onMessage.addListener((msg, sender, sendResponse) => {
    // 处理 CLICK_NOW 消息
    if (msg?.type === "CLICK_NOW") {
      handleClickNow(sendResponse);
      return true; // 保持消息通道开放以进行异步响应
    }

    // 处理 API_DOWNLOAD 消息
    if (msg?.type === "API_DOWNLOAD") {
      handleApiDownload(sendResponse);
      return true; // 保持消息通道开放以进行异步响应
    }

    if (msg?.type === "SET_XPATH" && typeof msg.xpath === "string") {
      XPATH = msg.xpath;
      chrome.storage?.local?.set?.({ ding_xpath: XPATH });
      sendResponse({ success: true });
    }
  });

  // 初始化：从 storage 读取自定义 XPath
  chrome.storage?.local?.get?.(["ding_xpath"], v => {
    if (v?.ding_xpath) {
      XPATH = v.ding_xpath;
    }
  });

}